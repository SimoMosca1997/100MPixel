<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Interactive Pixel Grid</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: Arial, sans-serif;
      overflow: hidden;
    }

    canvas {
      display: block;
      cursor: grab;
    }

    #popup {
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background: white;
      padding: 20px;
      box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
      border-radius: 8px;
      display: none;
      z-index: 10;
    }

    #popup input {
      margin-bottom: 10px;
      width: 100%;
      padding: 8px;
      border: 1px solid #ccc;
      border-radius: 4px;
    }

    #popup button {
      padding: 10px 20px;
      background-color: #007bff;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }

    #popup button:hover {
      background-color: #0056b3;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  <div id="popup">
    <h3>Set Pixel Data</h3>
    <input type="text" id="imageUrl" placeholder="Image URL">
    <input type="text" id="linkUrl" placeholder="Link URL (optional)">
    <button id="savePixel">Save</button>
  </div>

  <script>
    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const popup = document.getElementById("popup");
    const imageUrlInput = document.getElementById("imageUrl");
    const linkUrlInput = document.getElementById("linkUrl");
    const savePixelButton = document.getElementById("savePixel");

    let gridSize = 20; // Number of squares per row and column
    let pixelSize;
    let gridData = JSON.parse(localStorage.getItem("gridData")) || {}; // Load saved data

    let isDragging = false;
    let offsetX = 0;
    let offsetY = 0;
    let startDragX = 0;
    let startDragY = 0;
    let zoomLevel = 1;
    let selectedPixel = null;

    function resizeCanvas() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      pixelSize = Math.min(canvas.width, canvas.height) / gridSize;
      drawGrid();
    }

    function drawGrid() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      for (let x = 0; x < gridSize; x++) {
        for (let y = 0; y < gridSize; y++) {
          const pixelX = x * pixelSize - offsetX;
          const pixelY = y * pixelSize - offsetY;

          // Draw grid square
          ctx.strokeStyle = "#ddd";
          ctx.strokeRect(pixelX, pixelY, pixelSize, pixelSize);

          // Draw image if exists
          const key = `${x},${y}`;
          if (gridData[key] && gridData[key].image) {
            const img = new Image();
            img.src = gridData[key].image;
            img.onload = () => {
              ctx.drawImage(img, pixelX, pixelY, pixelSize, pixelSize);
            };
          }
        }
      }
    }

    function showPopup(x, y) {
      popup.style.display = "block";
      selectedPixel = { x, y };
    }

    function hidePopup() {
      popup.style.display = "none";
      selectedPixel = null;
    }

    function savePixelData() {
      if (!selectedPixel) return;

      const { x, y } = selectedPixel;
      const imageUrl = imageUrlInput.value.trim();
      const linkUrl = linkUrlInput.value.trim();

      if (!imageUrl) {
        alert("Image URL is required!");
        return;
      }

      const key = `${x},${y}`;
      gridData[key] = {
        image: imageUrl,
        link: linkUrl || null,
      };

      localStorage.setItem("gridData", JSON.stringify(gridData)); // Save to localStorage
      drawGrid();
      hidePopup();
    }

    canvas.addEventListener("mousedown", (e) => {
      const rect = canvas.getBoundingClientRect();
      const mouseX = (e.clientX - rect.left) / zoomLevel + offsetX;
      const mouseY = (e.clientY - rect.top) / zoomLevel + offsetY;

      const x = Math.floor(mouseX / pixelSize);
      const y = Math.floor(mouseY / pixelSize);

      const key = `${x},${y}`;
      if (gridData[key] && gridData[key].link) {
        window.open(gridData[key].link, "_blank");
        return;
      }

      isDragging = true;
      startDragX = e.clientX;
      startDragY = e.clientY;
    });

    canvas.addEventListener("mouseup", (e) => {
      if (!isDragging) {
        const rect = canvas.getBoundingClientRect();
        const mouseX = (e.clientX - rect.left) / zoomLevel + offsetX;
        const mouseY = (e.clientY - rect.top) / zoomLevel + offsetY;

        const x = Math.floor(mouseX / pixelSize);
        const y = Math.floor(mouseY / pixelSize);

        showPopup(x, y);
      }

      isDragging = false;
    });

    canvas.addEventListener("mousemove", (e) => {
      if (isDragging) {
        offsetX -= (e.clientX - startDragX) / zoomLevel;
        offsetY -= (e.clientY - startDragY) / zoomLevel;
        startDragX = e.clientX;
        startDragY = e.clientY;
        drawGrid();
      }
    });

    canvas.addEventListener("wheel", (e) => {
      e.preventDefault();
      const zoomAmount = e.deltaY > 0 ? 0.9 : 1.1;
      zoomLevel *= zoomAmount;
      zoomLevel = Math.max(0.5, Math.min(5, zoomLevel));
      ctx.setTransform(zoomLevel, 0, 0, zoomLevel, 0, 0);
      drawGrid();
    });

    window.addEventListener("resize", resizeCanvas);
    savePixelButton.addEventListener("click", savePixelData);

    resizeCanvas();
  </script>
</body>
</html>
